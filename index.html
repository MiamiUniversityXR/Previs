<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MUXR Previs</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Bebas+Neue&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --ink: #0a0a0a;
    --paper: #f0ece4;
    --accent: #e8380d;
    --dim: #b0a898;
    --ui-bg: rgba(10,10,10,0.92);
    --panel-w: 285px;
    --bottom-h: 48px;
    --font-mono: 'JetBrains Mono', 'Courier New', monospace;
  }

  html, body { width: 100%; height: 100%; overflow: hidden; background: var(--ink); }
  canvas { display: block; }

  #hud {
    position: fixed; inset: 0; pointer-events: none;
    font-family: var(--font-mono); color: var(--paper); z-index: 10;
  }

  /* CROSSHAIR */
  #crosshair {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
    width: 20px; height: 20px; pointer-events: none;
  }
  #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(240,236,228,0.5); }
  #crosshair::before { width:1px; height:100%; left:50%; top:0; }
  #crosshair::after  { width:100%; height:1px; top:50%; left:0; }

  /* LEFT PANEL */
  #panel-left {
    position: absolute; top:0; left:0; bottom:0; width: var(--panel-w);
    background: var(--ui-bg); border-right: 1px solid rgba(240,236,228,0.08);
    display: flex; flex-direction: column;
    pointer-events: all; backdrop-filter: blur(8px);
    transition: transform 0.3s ease; z-index: 20;
  }
  #brand {
    padding: 18px 20px 14px; border-bottom: 1px solid rgba(240,236,228,0.08); flex-shrink: 0;
  }
  #brand h1 { font-family: 'Bebas Neue', sans-serif; font-size: 36px; letter-spacing: 5px; color: var(--paper); line-height: 1; }
  #brand p  { font-size: 8px; letter-spacing: 3px; color: var(--dim); text-transform: uppercase; margin-top: 3px; }

  #panel-left .section-label {
    font-size: 8px; letter-spacing: 3px; color: var(--dim);
    padding: 12px 20px; text-transform: uppercase;
    border-bottom: 1px solid rgba(240,236,228,0.08); flex-shrink: 0;
  }
  #lens-list {
    overflow-y: auto; flex: 1;
    scrollbar-width: thin; scrollbar-color: rgba(240,236,228,0.1) transparent;
  }
  #lens-list::-webkit-scrollbar { width: 3px; }
  #lens-list::-webkit-scrollbar-thumb { background: rgba(240,236,228,0.1); }

  .lens-item {
    cursor: pointer; padding: 11px 20px; border-left: 2px solid transparent;
    transition: all 0.15s; user-select: none; position: relative;
  }
  .lens-item:hover { background: rgba(240,236,228,0.05); }
  .lens-item.active { border-left-color: var(--accent); background: rgba(232,56,13,0.08); }
  .lens-name { font-size: 11px; font-weight: 700; color: var(--paper); margin-bottom: 3px; }
  .lens-meta { font-size: 9px; color: var(--dim); }
  .lens-meta span { color: var(--accent); font-weight: 700; }
  .zoom-badge {
    display: inline-block; font-size: 7px; letter-spacing: 2px;
    color: var(--accent); border: 1px solid var(--accent); padding: 1px 4px; margin-left: 5px; vertical-align: middle;
  }
  .lens-delete {
    display: none; position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
    background: none; border: none; color: rgba(232,56,13,0.45); font-size: 18px;
    cursor: pointer; line-height: 1; padding: 2px 5px; transition: color 0.15s;
  }
  .lens-item:hover .lens-delete { display: block; }
  .lens-delete:hover { color: var(--accent); }

  #btn-add-lens {
    pointer-events: all; cursor: pointer; background: transparent;
    border-top: 1px solid rgba(240,236,228,0.08); border-bottom: 1px solid rgba(240,236,228,0.08);
    border-left: none; border-right: none; color: var(--dim);
    font-family: var(--font-mono); font-size: 8px; font-weight: 700;
    letter-spacing: 3px; text-transform: uppercase; padding: 12px 20px;
    display: flex; align-items: center; gap: 8px; transition: all 0.15s; width: 100%; flex-shrink: 0;
  }
  #btn-add-lens:hover { color: var(--accent); border-color: rgba(232,56,13,0.25); background: rgba(232,56,13,0.04); }

  #zoom-strip { padding: 14px 20px; border-top: 1px solid rgba(240,236,228,0.08); flex-shrink: 0; }
  #zoom-strip label { font-size: 8px; letter-spacing: 3px; color: var(--dim); display: block; margin-bottom: 10px; text-transform: uppercase; }
  #fov-slider { -webkit-appearance: none; width: 100%; height: 2px; background: rgba(240,236,228,0.15); outline: none; cursor: pointer; }
  #fov-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: grab; }
  #fov-readout { font-size: 20px; font-family: 'Bebas Neue', sans-serif; letter-spacing: 2px; color: var(--paper); margin-top: 8px; }
  #fov-readout span { font-size: 8px; color: var(--dim); margin-left: 3px; letter-spacing: 1px; }

  /* RIGHT PANEL */
  #panel-right {
    position: absolute; top:0; right:0; bottom:0; width: var(--panel-w);
    background: var(--ui-bg); border-left: 1px solid rgba(240,236,228,0.08);
    padding: 0 0 24px; display: flex; flex-direction: column;
    pointer-events: all; backdrop-filter: blur(8px);
    overflow-y: auto; scrollbar-width: thin; scrollbar-color: rgba(240,236,228,0.1) transparent;
    transition: transform 0.3s ease; z-index: 20;
  }
  #panel-right::-webkit-scrollbar { width: 3px; }
  #panel-right::-webkit-scrollbar-thumb { background: rgba(240,236,228,0.1); }
  #panel-right .section-label {
    font-size: 8px; letter-spacing: 3px; color: var(--dim);
    padding: 18px 20px 12px; text-transform: uppercase;
    border-bottom: 1px solid rgba(240,236,228,0.08); margin-bottom: 16px; flex-shrink: 0;
  }

  .upload-slot { padding: 0 20px 20px; }
  .upload-slot h3 { font-size: 9px; letter-spacing: 2px; color: var(--paper); margin-bottom: 8px; text-transform: uppercase; }
  .drop-zone {
    border: 1px dashed rgba(240,236,228,0.2); padding: 16px 12px;
    text-align: center; cursor: pointer; transition: all 0.2s; position: relative;
  }
  .drop-zone:hover, .drop-zone.drag-over { border-color: var(--accent); background: rgba(232,56,13,0.05); }
  .drop-zone input[type=file] { position: absolute; inset:0; opacity:0; cursor:pointer; width:100%; height:100%; }
  .drop-zone .dz-icon { font-size: 18px; margin-bottom: 5px; display: block; color: var(--dim); }
  .drop-zone p { font-size: 8px; letter-spacing: 1px; color: var(--dim); }
  .drop-zone .dz-filename { font-size: 8px; color: var(--accent); margin-top: 5px; word-break: break-all; display: none; }
  .upload-divider { height: 1px; background: rgba(240,236,228,0.08); margin: 0 20px 20px; }

  .scale-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-top: 10px; padding: 0 2px 10px 2px;
  }
  .scale-row label { font-size: 8px; letter-spacing: 2px; color: var(--dim); text-transform: uppercase; }
  .scale-row input[type=number] {
    width: 80px; background: rgba(240,236,228,0.04);
    border: 1px solid rgba(240,236,228,0.14); color: var(--paper);
    font-family: var(--font-mono); font-size: 11px; padding: 6px 8px;
    outline: none; text-align: right; -moz-appearance: textfield; transition: border-color 0.15s;
  }
  .scale-row input[type=number]:focus { border-color: var(--accent); }
  .scale-row input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; }

  .transform-grid { padding: 0 0 4px; }
  .transform-grid .field-row { display: flex; gap: 10px; }
  .transform-grid .field-group { flex: 1; }
  .transform-grid .field-group label {
    display: block; font-size: 8px; letter-spacing: 1px;
    color: var(--dim); text-transform: uppercase; margin-bottom: 5px;
  }
  .inline-fields { display: flex; gap: 4px; }
  .inline-fields input {
    flex: 1; min-width: 0; background: rgba(240,236,228,0.04);
    border: 1px solid rgba(240,236,228,0.14); color: var(--paper);
    font-family: var(--font-mono); font-size: 10px; padding: 5px 4px;
    outline: none; text-align: center; -moz-appearance: textfield; transition: border-color 0.15s;
  }
  .inline-fields input:focus { border-color: var(--accent); }
  .inline-fields input::-webkit-inner-spin-button { -webkit-appearance: none; }

  /* BOTTOM BAR */
  #bottom-bar {
    position: absolute; bottom:0; left: var(--panel-w); right: var(--panel-w);
    height: var(--bottom-h); background: var(--ui-bg);
    border-top: 1px solid rgba(240,236,228,0.08);
    display: flex; align-items: center; justify-content: center;
    gap: 20px; backdrop-filter: blur(8px); pointer-events: none; overflow: hidden; z-index: 15;
  }
  .ctrl-hint { font-size: 8px; letter-spacing: 2px; color: var(--dim); text-transform: uppercase; display: flex; align-items: center; gap: 4px; }
  .ctrl-hint kbd { display: inline-block; border: 1px solid rgba(240,236,228,0.2); padding: 2px 4px; font-family: var(--font-mono); font-size: 7px; color: var(--paper); border-radius: 2px; }
  #btn-export {
    pointer-events: all; cursor: pointer; background: var(--accent); border: none;
    color: var(--paper); font-family: var(--font-mono); font-size: 8px; font-weight: 700;
    letter-spacing: 2px; text-transform: uppercase; padding: 0 18px; height: 100%;
    display: flex; align-items: center; gap: 6px; transition: background 0.15s; flex-shrink: 0;
  }
  #btn-export:hover { background: #ff4e22; }
  #btn-export:active { filter: brightness(0.88); }

  /* MODAL */
  #modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.78);
    z-index: 100; display: flex; align-items: center; justify-content: center;
    backdrop-filter: blur(6px); opacity: 0; pointer-events: none; transition: opacity 0.2s;
  }
  #modal-overlay.open { opacity: 1; pointer-events: all; }
  #modal {
    background: #111; border: 1px solid rgba(240,236,228,0.12);
    width: min(400px, calc(100vw - 32px)); padding: 28px;
    transform: translateY(14px); transition: transform 0.2s;
  }
  #modal-overlay.open #modal { transform: translateY(0); }
  #modal h2 { font-family: 'Bebas Neue', sans-serif; font-size: 28px; letter-spacing: 5px; color: var(--paper); margin-bottom: 4px; }
  .modal-sub { font-size: 8px; letter-spacing: 2px; color: var(--dim); text-transform: uppercase; margin-bottom: 24px; }
  .field-group { margin-bottom: 16px; }
  .field-group label { display: block; font-size: 8px; letter-spacing: 2px; color: var(--dim); text-transform: uppercase; margin-bottom: 6px; }
  .field-group input[type=text], .field-group input[type=number] {
    width: 100%; background: rgba(240,236,228,0.04); border: 1px solid rgba(240,236,228,0.14);
    color: var(--paper); font-family: var(--font-mono); font-size: 13px;
    padding: 10px 12px; outline: none; transition: border-color 0.15s; -moz-appearance: textfield;
  }
  .field-group input:focus { border-color: var(--accent); }
  .field-group input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; }
  .field-row { display: flex; gap: 12px; }
  .field-row .field-group { flex: 1; }
  #end-fov-group { transition: opacity 0.2s; }
  #end-fov-group.hidden { opacity: 0.25; pointer-events: none; }

  .toggle-wrap { display: flex; align-items: center; gap: 14px; }
  .toggle { position: relative; width: 40px; height: 22px; flex-shrink: 0; }
  .toggle input { opacity: 0; width: 0; height: 0; }
  .toggle-track { position: absolute; inset: 0; background: rgba(240,236,228,0.08); border: 1px solid rgba(240,236,228,0.18); cursor: pointer; transition: all 0.2s; }
  .toggle-track::after { content: ''; position: absolute; left: 3px; top: 3px; width: 14px; height: 14px; background: var(--dim); transition: all 0.2s; }
  .toggle input:checked + .toggle-track { background: rgba(232,56,13,0.18); border-color: var(--accent); }
  .toggle input:checked + .toggle-track::after { left: 21px; background: var(--accent); }
  .toggle-label { font-size: 10px; letter-spacing: 1px; color: var(--paper); }
  .modal-error { font-size: 8px; color: var(--accent); letter-spacing: 1px; margin-top: 10px; min-height: 14px; }
  .modal-actions { display: flex; gap: 10px; margin-top: 22px; }
  .btn-primary { flex: 1; background: var(--accent); border: none; color: var(--paper); font-family: var(--font-mono); font-size: 9px; font-weight: 700; letter-spacing: 2px; text-transform: uppercase; padding: 13px; cursor: pointer; transition: background 0.15s; }
  .btn-primary:hover { background: #ff4e22; }
  .btn-secondary { background: transparent; border: 1px solid rgba(240,236,228,0.14); color: var(--dim); font-family: var(--font-mono); font-size: 9px; letter-spacing: 2px; text-transform: uppercase; padding: 13px 18px; cursor: pointer; transition: all 0.15s; }
  .btn-secondary:hover { border-color: var(--paper); color: var(--paper); }

  /* Tab buttons — mobile only, hidden on desktop */
  #tab-left-mobile, #tab-right-mobile { display: none; }

  /* TABLET ≤ 1024px */
  @media (max-width: 1024px) {
    :root { --panel-w: 230px; }
    .ctrl-hint { display: none; }
    #bottom-bar { gap: 0; justify-content: flex-end; }
    #brand h1 { font-size: 28px; }
    #brand p  { font-size: 7px; }
  }

  /* MOBILE ≤ 700px — panels become slide-in drawers */
  @media (max-width: 700px) {
    :root { --panel-w: 280px; --bottom-h: 52px; }

    #panel-left  { transform: translateX(-100%); bottom: var(--bottom-h); }
    #panel-right { transform: translateX(100%);  bottom: var(--bottom-h); }
    #panel-left.open  { transform: translateX(0); }
    #panel-right.open { transform: translateX(0); }

    #bottom-bar { left: 0; right: 0; justify-content: space-between; padding: 0; gap: 0; }
    .ctrl-hint { display: none; }

    #tab-left-mobile, #tab-right-mobile {
      pointer-events: all; height: 100%;
      display: flex; align-items: center;
      background: transparent; border: none; color: var(--dim);
      font-family: var(--font-mono); font-size: 8px; letter-spacing: 2px; text-transform: uppercase;
      padding: 0 16px; cursor: pointer; gap: 6px; flex-shrink: 0; transition: color 0.15s;
    }
    #tab-left-mobile  { border-right: 1px solid rgba(240,236,228,0.08); }
    #tab-right-mobile { border-left:  1px solid rgba(240,236,228,0.08); }
    #tab-left-mobile.active,  #tab-left-mobile:hover  { color: var(--accent); }
    #tab-right-mobile.active, #tab-right-mobile:hover { color: var(--accent); }

    #btn-export { flex: 1; justify-content: center; }
  }
</style>
</head>
<body>

<div id="hud">
  <div id="crosshair"></div>

  <div id="panel-left">
    <div id="brand">
      <h1>MUXR Previs</h1>
      <p>RED KOMODO &mdash; Super 35 / APS-C</p>
    </div>
    <div class="section-label">Lens Selection</div>
    <div id="lens-list"></div>
    <button id="btn-add-lens">&#43;&nbsp;&nbsp;Custom Lens</button>
    <div id="zoom-strip">
      <label>Focal Length &mdash; Super 35</label>
      <input type="range" id="fov-slider" min="0" max="1" step="0.001" value="0">
      <div id="fov-readout">35mm<span>actual &nbsp;|&nbsp; 51mm FF equiv</span></div>
    </div>
  </div>

  <div id="panel-right">
    <div class="section-label">Scene Content</div>

    <div class="upload-slot">
      <h3>Wall Texture (4752&times;1584)</h3>
      <div class="drop-zone" id="dz-wall">
        <input type="file" id="file-wall" accept="image/*,video/*">
        <span class="dz-icon">&#9633;</span>
        <p>Image or Video</p>
        <div class="dz-filename" id="fn-wall"></div>
      </div>
    </div>

    <div class="upload-divider"></div>

    <div class="upload-slot">
      <h3>Floor Texture (1280&times;896)</h3>
      <div class="drop-zone" id="dz-floor">
        <input type="file" id="file-floor" accept="image/*,video/*">
        <span class="dz-icon">&#9633;</span>
        <p>Image or Video</p>
        <div class="dz-filename" id="fn-floor"></div>
      </div>
    </div>

    <div class="upload-divider"></div>

    <div class="upload-slot">
      <h3>Stand-In Mesh</h3>
      <div class="drop-zone" id="dz-standin">
        <input type="file" id="file-standin" accept=".obj">
        <span class="dz-icon">&#9635;</span>
        <p>meshes/standin.obj</p>
        <div class="dz-filename" id="fn-standin"></div>
      </div>
      <div class="scale-row">
        <label for="standin-scale">Scale</label>
        <input type="number" id="standin-scale" value=".01" min="0.001" step="0.01">
      </div>
      <div class="transform-grid">
        <div class="field-row">
          <div class="field-group">
            <label>Position (m)</label>
            <div class="inline-fields">
              <input type="number" id="standin-pos-x" value="0"   step="0.01" title="X">
              <input type="number" id="standin-pos-y" value="0"   step="0.01" title="Y">
              <input type="number" id="standin-pos-z" value="2.5" step="0.01" title="Z">
            </div>
          </div>
          <div class="field-group">
            <label>Rotation (&deg;)</label>
            <div class="inline-fields">
              <input type="number" id="standin-rot-x" value="0" step="1" title="RX">
              <input type="number" id="standin-rot-y" value="0" step="1" title="RY">
              <input type="number" id="standin-rot-z" value="0" step="1" title="RZ">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="bottom-bar">
    <div class="ctrl-hint"><kbd>W A S D</kbd> Move</div>
    <div class="ctrl-hint"><kbd>DRAG</kbd> Look</div>
    <div class="ctrl-hint"><kbd>SHIFT</kbd> Sprint</div>
    <div class="ctrl-hint"><kbd>SCROLL</kbd> Zoom</div>
    <button id="btn-export">&#9678;&nbsp; Export 16:9</button>
  </div>
</div>

<!-- Panel backdrop (mobile tap-to-close) -->
<div id="panel-backdrop" style="display:none;position:fixed;inset:0 0 var(--bottom-h) 0;background:rgba(0,0,0,0.5);z-index:19;pointer-events:all;"></div>

<!-- Custom Lens Modal -->
<div id="modal-overlay">
  <div id="modal">
    <h2>Custom Lens</h2>
    <p class="modal-sub">Define your own optic</p>
    <div class="field-group">
      <label>Lens Name</label>
      <input type="text" id="cl-name" placeholder="e.g. Vintage 35mm" maxlength="36" autocomplete="off">
    </div>
    <div class="field-row">
      <div class="field-group">
        <label>Start focal length</label>
        <input type="number" id="cl-fov-start" placeholder="25" min="1" max="999">
      </div>
      <div class="field-group" id="end-fov-group">
        <label>End focal length</label>
        <input type="number" id="cl-fov-end" placeholder="100" min="1" max="999">
      </div>
    </div>
    <div class="field-group">
      <label>Lens Type</label>
      <div class="toggle-wrap">
        <label class="toggle">
          <input type="checkbox" id="cl-zoom">
          <span class="toggle-track"></span>
        </label>
        <span class="toggle-label" id="zoom-toggle-label">Prime &mdash; fixed focal length</span>
      </div>
    </div>
    <div class="modal-error" id="modal-error"></div>
    <div class="modal-actions">
      <button class="btn-secondary" id="btn-modal-cancel">Cancel</button>
      <button class="btn-primary"   id="btn-modal-save">Add Lens</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ================================================================
// MOBILE PANEL TOGGLE
// ================================================================
(function () {
  const bar      = document.getElementById('bottom-bar');
  const panelL   = document.getElementById('panel-left');
  const panelR   = document.getElementById('panel-right');
  const backdrop = document.getElementById('panel-backdrop');
  const BP       = 700;

  const tabL = document.createElement('button'); tabL.id = 'tab-left-mobile';  tabL.innerHTML = '&#9776; Lenses';
  const tabR = document.createElement('button'); tabR.id = 'tab-right-mobile'; tabR.innerHTML = 'Scene &#9776;';
  bar.prepend(tabL); bar.appendChild(tabR);

  function isMobile() { return window.innerWidth <= BP; }
  function closeAll() {
    panelL.classList.remove('open'); panelR.classList.remove('open');
    tabL.classList.remove('active'); tabR.classList.remove('active');
    backdrop.style.display = 'none';
  }
  tabL.addEventListener('click', () => {
    if (!isMobile()) return;
    const opening = !panelL.classList.contains('open'); closeAll();
    if (opening) { panelL.classList.add('open'); tabL.classList.add('active'); backdrop.style.display = 'block'; }
  });
  tabR.addEventListener('click', () => {
    if (!isMobile()) return;
    const opening = !panelR.classList.contains('open'); closeAll();
    if (opening) { panelR.classList.add('open'); tabR.classList.add('active'); backdrop.style.display = 'block'; }
  });
  backdrop.addEventListener('click', closeAll);
  window.addEventListener('resize', () => { if (!isMobile()) closeAll(); });
}());

// ================================================================
// SENSOR — RED KOMODO Super 35 / APS-C
// ================================================================
const SENSOR_HEIGHT_MM = 14.26;
const CROP_FACTOR      = 1.46;
function focalToFov(mm)  { return 2 * Math.atan(SENSOR_HEIGHT_MM / (2 * mm)) * (180 / Math.PI); }
function fovToFocalMm(f) { return SENSOR_HEIGHT_MM / (2 * Math.tan((f / 2) * (Math.PI / 180))); }
function fovToMm(fov)    { return Math.round(fovToFocalMm(fov)); }
function fovToFFMm(fov)  { return Math.round(fovToFocalMm(fov) * CROP_FACTOR); }

// ================================================================
// LENS DATA
// ================================================================
const LENSES = [
  { name: '50-100mm T2 Sigma Cine-zoom', startFov: focalToFov(50),  endFov: focalToFov(100), zoom: true  },
  { name: '15mm T2.1 Zeiss CP.3',        startFov: focalToFov(15),  endFov: focalToFov(15),  zoom: false },
  { name: '25mm T2.1 Zeiss CP.3',        startFov: focalToFov(25),  endFov: focalToFov(25),  zoom: false },
  { name: '35mm T2.1 Zeiss CP.3',        startFov: focalToFov(35),  endFov: focalToFov(35),  zoom: false },
  { name: '50mm T2.1 Zeiss CP.3',        startFov: focalToFov(50),  endFov: focalToFov(50),  zoom: false },
  { name: '85mm T2.1 Zeiss CP.3',        startFov: focalToFov(85),  endFov: focalToFov(85),  zoom: false },
];
const NUM_BUILTIN = LENSES.length;

// ================================================================
// THREE.JS SETUP
// ================================================================
const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0e0e0e);
scene.fog = new THREE.Fog(0x0e0e0e, 20, 60);

const camera = new THREE.PerspectiveCamera(focalToFov(35), window.innerWidth / window.innerHeight, 0.05, 200);
camera.position.set(0, 1.7, 10);

scene.add(new THREE.AmbientLight(0xfff0e0, 0.4));
const spot = new THREE.SpotLight(0xfff5e8, 1.6, 40, Math.PI / 6, 0.5);
spot.position.set(0, 10, 2.5); spot.castShadow = true; spot.shadow.mapSize.set(2048, 2048);
scene.add(spot);
const flLight = new THREE.PointLight(0x4466cc, 0.3, 20); flLight.position.set(-4, 4, 8); scene.add(flLight);
const frLight = new THREE.PointLight(0xcc6644, 0.2, 20); frLight.position.set(0, 4, 9);  scene.add(frLight);

// ================================================================
// OBJ LOADER
// ================================================================
// ================================================================
// DEFAULT GRID TEXTURES — 352px per metre, anchored to nearest
// grid line from center so alignment is exact
// ================================================================
function makeGridTexture(W, H, cellPx) {
  const cv = document.createElement('canvas');
  cv.width = W; cv.height = H;
  const ctx = cv.getContext('2d');

  ctx.fillStyle = '#111111';
  ctx.fillRect(0, 0, W, H);

  // Snap anchor to the grid line nearest the texture center
  const anchorX = Math.round((W / 2) / cellPx) * cellPx;
  const anchorY = Math.round((H / 2) / cellPx) * cellPx;

  // Build all line positions radiating outward from the anchor
  function getLines(anchor, size, step) {
    const lines = [];
    for (let p = anchor; p <= size + step; p += step) lines.push(p);
    for (let p = anchor - step; p >= -step; p -= step) lines.push(p);
    return lines.filter(p => p >= 0 && p <= size);
  }

  const minorX = getLines(anchorX, W, cellPx);
  const minorY = getLines(anchorY, H, cellPx);
  const majorX = getLines(anchorX, W, cellPx * 5);
  const majorY = getLines(anchorY, H, cellPx * 5);

  // Use sets for fast major-line lookup
  const majSetX = new Set(majorX.map(x => Math.round(x)));
  const majSetY = new Set(majorY.map(y => Math.round(y)));

  // Minor lines — 1m, white
  ctx.strokeStyle = 'rgba(255,255,255,0.22)';
  ctx.lineWidth = 2;
  for (const x of minorX) {
    if (majSetX.has(Math.round(x))) continue;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (const y of minorY) {
    if (majSetY.has(Math.round(y))) continue;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Major lines — 5m, accent
  ctx.strokeStyle = 'rgba(232,100,60,0.7)';
  ctx.lineWidth = 4;
  for (const x of majorX) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (const y of majorY) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  return cv; // return canvas so callers can composite onto it
}

function canvasToTex(cv) {
  const tex = new THREE.CanvasTexture(cv);
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.minFilter = THREE.LinearMipmapLinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = true;
  return tex;
}

// Floor texture — simple grid, sync
const floorGridTex = canvasToTex(makeGridTexture(2146, 1504, 352));

// Wall texture — grid + MUXR logo centered, async SVG load
const wallGridCanvas = makeGridTexture(4752, 1584, 352);
const wallGridTex    = canvasToTex(wallGridCanvas); // starts rendering immediately; logo composited after load

(function () {
  const SVG_W = 3998, SVG_H = 921.28;
  const TW = 4752, TH = 1584;

  // Scale logo to 72% of wall width, centred
  const logoW = TW * 0.72;
  const logoH = logoW * (SVG_H / SVG_W);
  const logoX = (TW - logoW) / 2;
  const logoY = (TH - logoH) / 2;

  // Inline the SVG as a data URI — no fetch needed, no CORS
  const svgSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
    `<svg width="${SVG_W}" height="${SVG_H}" viewBox="0 0 ${SVG_W} ${SVG_H}" xmlns="http://www.w3.org/2000/svg"><path d="M588.530029296875,0L771.0499877929688,624.35009765625L954.6199951171875,0L1564.4300537109375,0L1564.4300537109375,536.3798828125C1564.4300537109375,536.3798828125,1561.949951171875,689,1745.7099609375,689C1929.469970703125,689,1926.1600341796875,536.3798828125,1926.1600341796875,536.3798828125L1926.1600341796875,0L2306.919921875,0L2577.590087890625,378.39990234375L2849.919921875,0L3623.030029296875,0C3744.7099609375,0,3998,52.1500244140625,3998,299.22998046875C3998,546.31005859375,3742.22998046875,591.010009765625,3742.22998046875,591.010009765625L3987.239990234375,921.280029296875L3594.419921875,921.280029296875L3379.679931640625,601.889892578125L3248.070068359375,601.889892578125L3248.070068359375,921.280029296875L2849.929931640625,921.280029296875L2577.60009765625,545.840087890625L2306.929931640625,921.280029296875L1188.530029296875,921.280029296875L1188.530029296875,320.340087890625L981.3599853515625,921.280029296875L566.1900024414062,921.280029296875L356.05999755859375,320.340087890625L356.05999755859375,921.280029296875L0,921.280029296875L0,0L588.530029296875,0ZM3248.06005859375,375.239990234375L3556.889892578125,375.239990234375C3556.889892578125,375.239990234375,3633.300048828125,372.47998046875,3633.300048828125,299.89990234375C3633.300048828125,227.320068359375,3556.889892578125,223.489990234375,3556.889892578125,223.489990234375L3248.06005859375,223.489990234375L3248.06005859375,375.239990234375Z" fill="rgba(255,255,255,0.18)"/></svg>`
  )}`;

  const img = new Image();
  img.onload = function () {
    const ctx = wallGridCanvas.getContext('2d');
    ctx.drawImage(img, logoX, logoY, logoW, logoH);
    wallGridTex.needsUpdate = true;
  };
  img.src = svgSrc;
}());

const wallMat  = new THREE.MeshBasicMaterial({ map: wallGridTex,  color: 0xffffff });
const floorMat = new THREE.MeshBasicMaterial({ map: floorGridTex, color: 0xffffff });
const StageRoomMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.8, metalness: 0.2, transparent: true, opacity: 0.5 });
const standinMat   = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6, metalness: 0.1 });

const wall    = { material: wallMat,      meshes: [] };
const floor   = { material: floorMat,     meshes: [] };
const room    = { material: StageRoomMat, meshes: [] };
const standin = { material: standinMat,   meshes: [] };

function loadOBJFromText(text, proxy, mat) {
  const pos = [], uvs = [], nrm = [], pO = [], uO = [], nO = [];
  for (const raw of text.split('\n')) {
    const l = raw.trim();
    if (l.startsWith('v '))  { const [,x,y,z] = l.split(/\s+/); pos.push(+x,+y,+z); }
    else if (l.startsWith('vt ')) { const [,u,v] = l.split(/\s+/); uvs.push(+u,+v); }
    else if (l.startsWith('vn ')) { const [,x,y,z] = l.split(/\s+/); nrm.push(+x,+y,+z); }
    else if (l.startsWith('f ')) {
      const vv = l.slice(2).trim().split(/\s+/);
      for (let i = 1; i < vv.length - 1; i++) {
        for (const v of [vv[0], vv[i], vv[i+1]]) {
          const p = v.split('/'), pi = (parseInt(p[0])-1)*3;
          pO.push(pos[pi], pos[pi+1], pos[pi+2]);
          if (p[1] && p[1] !== '' && uvs.length) { const ti=(parseInt(p[1])-1)*2; uO.push(uvs[ti],uvs[ti+1]); }
          if (p[2] && nrm.length) { const ni=(parseInt(p[2])-1)*3; nO.push(nrm[ni],nrm[ni+1],nrm[ni+2]); }
        }
      }
    }
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pO, 3));
  if (uO.length) geo.setAttribute('uv',     new THREE.Float32BufferAttribute(uO, 2));
  if (nO.length) geo.setAttribute('normal', new THREE.Float32BufferAttribute(nO, 3));
  else           geo.computeVertexNormals();
  for (const m of proxy.meshes) scene.remove(m);
  proxy.meshes.length = 0;
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh); proxy.meshes.push(mesh);
}

// ================================================================
// METER GRID 46x46m
// ================================================================
(function () {
  const SIZE = 46, CELLS = 46, PX = 40, W = CELLS*PX, H = CELLS*PX;
  const cv = document.createElement('canvas'); cv.width = W; cv.height = H;
  const ctx = cv.getContext('2d'); ctx.clearRect(0, 0, W, H);
  ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1;
  for (let i = 0; i <= CELLS; i++) { const x=i*PX; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,x); ctx.lineTo(W,x); ctx.stroke(); }
  ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
  for (let i = 0; i <= CELLS; i+=5) { const x=i*PX; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,x); ctx.lineTo(W,x); ctx.stroke(); }
  const cx = (CELLS/2)*PX; ctx.strokeStyle = 'rgba(200,120,110,0.7)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,cx); ctx.lineTo(W,cx); ctx.stroke();
  const tex = new THREE.CanvasTexture(cv); tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  const gm = new THREE.Mesh(new THREE.PlaneGeometry(SIZE,SIZE), new THREE.MeshBasicMaterial({ map:tex, transparent:true, opacity:1, depthWrite:false, side:THREE.DoubleSide }));
  gm.rotation.x = -Math.PI/2; gm.position.set(0, 0.05, 0); scene.add(gm);
}());

// ================================================================
// CAMERA CONTROLLER
// ================================================================
const keys = {};
document.addEventListener('keydown', e => { if (!e.target.matches('input,textarea')) keys[e.code] = true; });
document.addEventListener('keyup',   e => keys[e.code] = false);
let pitch=0, yaw=0, dragging=false, lastX=0, lastY=0;
renderer.domElement.addEventListener('mousedown', e => { if (e.target!==renderer.domElement) return; dragging=true; lastX=e.clientX; lastY=e.clientY; });
document.addEventListener('mouseup',   () => dragging=false);
document.addEventListener('mousemove', e => { if (!dragging) return; yaw-=(e.clientX-lastX)*0.002; pitch-=(e.clientY-lastY)*0.002; pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch)); lastX=e.clientX; lastY=e.clientY; });
renderer.domElement.addEventListener('touchstart', e => { dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }, { passive:true });
document.addEventListener('touchend',  () => dragging=false);
document.addEventListener('touchmove', e => { if (!dragging) return; yaw-=(e.touches[0].clientX-lastX)*0.003; pitch-=(e.touches[0].clientY-lastY)*0.003; pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch)); lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }, { passive:true });

function updateCamera(dt) {
  const speed = (keys['ShiftLeft']||keys['ShiftRight']) ? 8 : 2.5;
  const fwd   = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
  const right = new THREE.Vector3( Math.cos(yaw), 0, -Math.sin(yaw));
  if (keys['KeyW']||keys['ArrowUp'])    camera.position.addScaledVector(fwd,    speed*dt);
  if (keys['KeyS']||keys['ArrowDown'])  camera.position.addScaledVector(fwd,   -speed*dt);
  if (keys['KeyA']||keys['ArrowLeft'])  camera.position.addScaledVector(right, -speed*dt);
  if (keys['KeyD']||keys['ArrowRight']) camera.position.addScaledVector(right,  speed*dt);
  if (keys['KeyQ']) camera.position.y += speed*dt*0.5;
  if (keys['KeyE']) camera.position.y -= speed*dt*0.5;
  camera.position.y = Math.max(0.2, camera.position.y);
  const qY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw);
  const qX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitch);
  camera.quaternion.copy(qY).multiply(qX);
}

// ================================================================
// FOV / LENS SYSTEM
// ================================================================
let currentLens = LENSES[2], currentFov = LENSES[2].startFov, targetFov = LENSES[2].startFov;
const fovSlider = document.getElementById('fov-slider'), fovReadout = document.getElementById('fov-readout');

function updateFovReadout(fov) {
  fovReadout.innerHTML = fovToMm(fov) + 'mm<span>actual &nbsp;|&nbsp; ' + fovToFFMm(fov) + 'mm FF equiv</span>';
}
function selectLens(index) {
  const lens = LENSES[index]; currentLens = lens; targetFov = lens.startFov;
  fovSlider.value = 0; fovSlider.disabled = !lens.zoom; fovSlider.style.opacity = lens.zoom ? '1' : '0.3';
  document.querySelectorAll('.lens-item').forEach(el => el.classList.toggle('active', parseInt(el.dataset.index) === index));
  updateFovReadout(lens.startFov);
}
fovSlider.addEventListener('input', () => {
  if (!currentLens.zoom) return;
  const t = parseFloat(fovSlider.value);
  targetFov = currentLens.startFov + t * (currentLens.endFov - currentLens.startFov);
  updateFovReadout(targetFov);
});
renderer.domElement.addEventListener('wheel', e => {
  if (!currentLens.zoom) return; e.preventDefault();
  let t = parseFloat(fovSlider.value) + e.deltaY * 0.001;
  t = Math.max(0, Math.min(1, t)); fovSlider.value = t;
  targetFov = currentLens.startFov + t * (currentLens.endFov - currentLens.startFov);
  updateFovReadout(targetFov);
}, { passive: false });

// ================================================================
// LENS LIST UI
// ================================================================
const lensList = document.getElementById('lens-list');
function rebuildLensList() {
  lensList.innerHTML = '';
  LENSES.forEach((lens, i) => {
    const isCustom = i >= NUM_BUILTIN;
    const el = document.createElement('div');
    el.className = 'lens-item'; if (lens === currentLens) el.classList.add('active'); el.dataset.index = i;
    el.innerHTML =
      '<div class="lens-name">' + lens.name +
      (lens.zoom ? '<span class="zoom-badge">ZOOM</span>' : '') +
      (isCustom  ? '<span class="zoom-badge" style="border-color:#b0a898;color:#b0a898;margin-left:3px">CUSTOM</span>' : '') + '</div>' +
      '<div class="lens-meta">FOV <span>' + lens.startFov.toFixed(2) + '&deg;</span>' +
      (lens.zoom ? ' &rarr; <span>' + lens.endFov.toFixed(2) + '&deg;</span>' : '') + '</div>' +
      (isCustom ? '<button class="lens-delete" title="Remove">&times;</button>' : '');
    el.addEventListener('click', e => { if (e.target.classList.contains('lens-delete')) return; selectLens(parseInt(el.dataset.index)); });
    if (isCustom) {
      el.querySelector('.lens-delete').addEventListener('click', e => {
        e.stopPropagation(); const idx = parseInt(el.dataset.index);
        if (currentLens === LENSES[idx]) selectLens(0);
        LENSES.splice(idx, 1); rebuildLensList();
      });
    }
    lensList.appendChild(el);
  });
}
rebuildLensList(); selectLens(2);

// ================================================================
// CUSTOM LENS MODAL
// ================================================================
const modalOverlay = document.getElementById('modal-overlay');
const clName = document.getElementById('cl-name'), clFovStart = document.getElementById('cl-fov-start');
const clFovEnd = document.getElementById('cl-fov-end'), clZoom = document.getElementById('cl-zoom');
const endFovGroup = document.getElementById('end-fov-group'), zoomToggleLabel = document.getElementById('zoom-toggle-label');
const modalError = document.getElementById('modal-error');

function openModal()  { clName.value=''; clFovStart.value=''; clFovEnd.value=''; clZoom.checked=false; endFovGroup.classList.add('hidden'); zoomToggleLabel.textContent='Prime \u2014 fixed focal length'; modalError.textContent=''; modalOverlay.classList.add('open'); setTimeout(()=>clName.focus(),160); }
function closeModal() { modalOverlay.classList.remove('open'); }

document.getElementById('btn-add-lens').addEventListener('click', openModal);
document.getElementById('btn-modal-cancel').addEventListener('click', closeModal);
modalOverlay.addEventListener('click', e => { if (e.target===modalOverlay) closeModal(); });
clZoom.addEventListener('change', () => { const z=clZoom.checked; endFovGroup.classList.toggle('hidden',!z); zoomToggleLabel.textContent = z ? 'Zoom \u2014 variable focal length' : 'Prime \u2014 fixed focal length'; });
document.getElementById('btn-modal-save').addEventListener('click', () => {
  modalError.textContent = '';
  const name=clName.value.trim(), sfov=parseFloat(clFovStart.value), isZ=clZoom.checked, efov=isZ?parseFloat(clFovEnd.value):sfov;
  if (!name) { modalError.textContent='A lens name is required.'; return; }
  if (isZ && efov===sfov) { modalError.textContent='Start and end focal length must differ.'; return; }
  LENSES.push({ name, startFov: focalToFov(sfov), endFov: focalToFov(efov), zoom: isZ });
  rebuildLensList(); closeModal(); setTimeout(() => selectLens(LENSES.length-1), 40);
});
document.addEventListener('keydown', e => { if (e.key==='Escape' && modalOverlay.classList.contains('open')) closeModal(); });

// ================================================================
// EXPORT 16:9
// ================================================================
const btnExport = document.getElementById('btn-export');
function exportFrame() {
  const EW=1920, EH=1080;
  btnExport.disabled=true; btnExport.textContent='Saving...';
  const p=camera.position, eu=new THREE.Euler().setFromQuaternion(camera.quaternion,'YXZ');
  const deg=r=>(r*180/Math.PI).toFixed(1), fix=n=>(n>=0?'+':'')+n.toFixed(2);
  const posLine ='X '+fix(p.x)+'   Y '+fix(p.y)+'   Z '+fix(p.z);
  const rotLine ='RX '+deg(eu.x)+'\u00b0   RY '+deg(eu.y)+'\u00b0   RZ '+deg(eu.z)+'\u00b0';
  const lensLine=currentLens.name.toUpperCase();
  const fovLine ='FOV '+currentFov.toFixed(2)+'\u00b0   '+fovToMm(currentFov)+'mm actual   \u2248'+fovToFFMm(currentFov)+'mm FF';
  camera.aspect=EW/EH; camera.updateProjectionMatrix();
  renderer.setSize(EW,EH,false); renderer.render(scene,camera);
  const sceneURL=renderer.domElement.toDataURL('image/png');
  camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight,false);
  const img=new Image();
  img.onload=function(){
    const out=document.createElement('canvas'); out.width=EW; out.height=EH;
    const ctx=out.getContext('2d'); ctx.drawImage(img,0,0,EW,EH);
    const grad=ctx.createLinearGradient(0,EH-140,0,EH); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.8)');
    ctx.fillStyle=grad; ctx.fillRect(0,EH-140,EW,140);
    function dt(text,x,y,font,align){ ctx.save(); ctx.font=font; ctx.textAlign=align; ctx.fillStyle='#fff'; ctx.shadowColor='rgba(0,0,0,1)'; ctx.shadowBlur=14; ctx.shadowOffsetX=ctx.shadowOffsetY=1; ctx.fillText(text,x,y); ctx.restore(); }
    const PAD=40,M='bold 20px "Courier New",monospace',MS='17px "Courier New",monospace';
    dt(posLine,PAD,EH-52,M,'left'); dt(rotLine,PAD,EH-22,M,'left'); dt(lensLine,EW-PAD,EH-52,M,'right'); dt(fovLine,EW-PAD,EH-22,MS,'right');
    out.toBlob(blob=>{
      const url=URL.createObjectURL(blob), ts=new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
      const a=document.createElement('a'); a.href=url; a.download='muxr-previs-'+ts+'.png';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      setTimeout(()=>URL.revokeObjectURL(url),5000);
      btnExport.disabled=false; btnExport.innerHTML='&#9678;&nbsp; Export 16:9';
    },'image/png');
  };
  img.onerror=()=>{ btnExport.disabled=false; btnExport.innerHTML='&#9678;&nbsp; Export 16:9'; };
  img.src=sceneURL;
}
btnExport.addEventListener('click', exportFrame);

// ================================================================
// MEDIA LOADER
// ================================================================
const videoElements = { wall: null, floor: null };
function applyTextureFromDataURL(dataURL, mesh) {
  const img=new Image();
  img.onload=function(){
    if (mesh.material.map) mesh.material.map.dispose();
    const tex=new THREE.Texture(img); tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
    tex.minFilter=tex.magFilter=THREE.LinearFilter; tex.flipY=true; tex.needsUpdate=true;
    mesh.material.map=tex; mesh.material.color.set(0xffffff); mesh.material.needsUpdate=true;
  };
  img.src=dataURL;
}
function applyMediaToMesh(file, mesh, matKey, fnEl) {
  fnEl.textContent=file.name; fnEl.style.display='block';
  if (videoElements[matKey]) { const o=videoElements[matKey]; o.pause(); o.removeAttribute('src'); o.load(); if (o.parentNode) o.parentNode.removeChild(o); videoElements[matKey]=null; }
  if (file.type.startsWith('video/')) {
    if (mesh.material.map) { mesh.material.map.dispose(); mesh.material.map=null; }
    const blobUrl=URL.createObjectURL(file), video=document.createElement('video');
    video.loop=video.muted=video.playsInline=true; video.preload='auto';
    video.style.cssText='position:fixed;width:1px;height:1px;opacity:0;pointer-events:none;top:-9999px;left:-9999px;';
    document.body.appendChild(video);
    video.addEventListener('loadeddata',function(){ video.play().catch(e=>console.warn('play():',e)); const tex=new THREE.VideoTexture(video); tex.minFilter=tex.magFilter=THREE.LinearFilter; mesh.material.map=tex; mesh.material.color.set(0xffffff); mesh.material.needsUpdate=true; videoElements[matKey]=video; },{ once:true });
    video.addEventListener('error',()=>URL.revokeObjectURL(blobUrl),{ once:true });
    video.src=blobUrl; video.load();
  } else {
    const reader=new FileReader(); reader.onload=e=>applyTextureFromDataURL(e.target.result,mesh); reader.onerror=()=>console.error('FileReader failed:',file.name); reader.readAsDataURL(file);
  }
}
function setupDropZone(dzId,fileId,fnId,mesh,key) {
  const dz=document.getElementById(dzId),input=document.getElementById(fileId),fn=document.getElementById(fnId);
  input.addEventListener('change',e=>{ if (e.target.files[0]) applyMediaToMesh(e.target.files[0],mesh,key,fn); });
  dz.addEventListener('dragover', e=>{ e.preventDefault(); dz.classList.add('drag-over'); });
  dz.addEventListener('dragleave',()=>dz.classList.remove('drag-over'));
  dz.addEventListener('drop',e=>{ e.preventDefault(); dz.classList.remove('drag-over'); const f=e.dataTransfer.files[0]; if (f&&(f.type.startsWith('image/')||f.type.startsWith('video/'))) applyMediaToMesh(f,mesh,key,fn); });
}
setupDropZone('dz-wall','file-wall','fn-wall',wall,'wall');
setupDropZone('dz-floor','file-floor','fn-floor',floor,'floor');

// ================================================================
// FETCH MESHES
// ================================================================
function fetchOBJ(path,proxy,mat) {
  return fetch(path).then(r=>{ if (!r.ok) throw new Error(r.status); return r.text(); }).then(text=>loadOBJFromText(text,proxy,mat)).catch(err=>console.error('Could not load '+path+':',err));
}
fetchOBJ('meshes/wall.obj',      wall,    wallMat);
fetchOBJ('meshes/floor.obj',     floor,   floorMat);
fetchOBJ('meshes/StageRoom.obj', room,    StageRoomMat);
fetchOBJ('meshes/standin.obj',   standin, standinMat).then(()=>applyStandinScale());

// ================================================================
// STAND-IN CONTROLS
// ================================================================
const standinInput=document.getElementById('file-standin'), standinFn=document.getElementById('fn-standin');
const standinScaleInput=document.getElementById('standin-scale');
const sPX=document.getElementById('standin-pos-x'), sPY=document.getElementById('standin-pos-y'), sPZ=document.getElementById('standin-pos-z');
const sRX=document.getElementById('standin-rot-x'), sRY=document.getElementById('standin-rot-y'), sRZ=document.getElementById('standin-rot-z');

function applyStandinScale() {
  const s=parseFloat(standinScaleInput.value); if (isNaN(s)||s<=0) return;
  for (const m of standin.meshes) m.scale.setScalar(s); applyStandinTransform();
}
function applyStandinTransform() {
  const px=parseFloat(sPX.value),py=parseFloat(sPY.value),pz=parseFloat(sPZ.value);
  const rx=parseFloat(sRX.value)*Math.PI/180, ry=parseFloat(sRY.value)*Math.PI/180, rz=parseFloat(sRZ.value)*Math.PI/180;
  for (const m of standin.meshes) {
    if (!isNaN(px)&&!isNaN(py)&&!isNaN(pz)) m.position.set(px,py,pz);
    if (!isNaN(rx)&&!isNaN(ry)&&!isNaN(rz)) m.rotation.set(rx,ry,rz);
  }
}
standinInput.addEventListener('change',e=>{ const file=e.target.files[0]; if (!file) return; standinFn.textContent=file.name; standinFn.style.display='block'; const reader=new FileReader(); reader.onload=ev=>{ loadOBJFromText(ev.target.result,standin,standinMat); applyStandinScale(); }; reader.readAsText(file); });
standinScaleInput.addEventListener('input', applyStandinScale);
[sPX,sPY,sPZ,sRX,sRY,sRZ].forEach(el=>el.addEventListener('input',applyStandinTransform));

// ================================================================
// RENDER LOOP
// ================================================================
let lastTime=performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now=performance.now(), dt=Math.min((now-lastTime)/1000,0.05); lastTime=now;
  updateCamera(dt);
  currentFov+=(targetFov-currentFov)*(1-Math.pow(0.001,dt));
  camera.fov=currentFov; camera.updateProjectionMatrix();
  for (const key of ['wall','floor']) {
    const vid=videoElements[key];
    if (vid&&!vid.paused&&vid.readyState>=vid.HAVE_CURRENT_DATA) { const mat=key==='wall'?wallMat:floorMat; if (mat.map) mat.map.needsUpdate=true; }
  }
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });
</script>
</body>
</html>
